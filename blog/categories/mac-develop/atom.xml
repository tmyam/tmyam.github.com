<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: mac_develop | tmyam's blog]]></title>
  <link href="http://tmyam.github.io/blog/categories/mac-develop/atom.xml" rel="self"/>
  <link href="http://tmyam.github.io/"/>
  <updated>2014-03-02T20:36:40+08:00</updated>
  <id>http://tmyam.github.io/</id>
  <author>
    <name><![CDATA[tmyam]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Objective-C遍历数组]]></title>
    <link href="http://tmyam.github.io/blog/2014/02/28/objective-cbian-li-shu-zu/"/>
    <updated>2014-02-28T11:46:00+08:00</updated>
    <id>http://tmyam.github.io/blog/2014/02/28/objective-cbian-li-shu-zu</id>
    <content type="html"><![CDATA[<p>数组的遍历有多种方式，这里介绍一下常见的方式，使用以及注意事项。</p>

<h2>常用写法简介</h2>

<h3>1. 经典写法</h3>

<p>``` objective-c
&ndash; (void) test:(NSArray*)array
{</p>

<pre><code>NSInteger count = array.count;
for (NSInteger i = 0 ; i &lt; count ; i ++ )
{
    NSLog(@"%@",array[i]);
}
NSLog(@"end");
</code></pre>

<p>}
```
之所以使用count来存储数组总数，而不是写成 <strong>i &lt; array.count</strong> ,是因为循环每进行一次都会调用数组的计数方法，这将导致性能变得很差。</p>

<!-- more -->


<h3>2. NSEnumerator</h3>

<p>``` objective-c
&ndash; (void) test:(NSArray*)array
{</p>

<pre><code>id test = nil;
NSEnumerator* enumerator = [array objectEnumerator];
while (test = [enumerator nextObject])
{
    NSLog(@"%@",test);
}
NSLog(@"end");
</code></pre>

<p>}
```
NSEnumerator的优势在于不需要知道数据总数，所以它适合应用在结构化数据上，比如链表，数据流等。</p>

<h3>3. 快速枚举</h3>

<p>``` objective-c
&ndash; (void) test:(NSArray*)array
{</p>

<pre><code>for (NSString* test in array )
{
    NSLog(@"%@",test);
}
NSLog(@"end");
</code></pre>

<p>}
```
快速枚举是apple推荐的方式，在使用上比经典的写法性能上更快。 <br/>
使用上如果需要反向枚举，只需要将<strong>array</strong>改成<strong>array.reverseObjectEnumerator</strong>就可以了。</p>

<h3>4. 枚举块</h3>

<p>``` objective-c
&ndash; (void) test:(NSArray*)array
{</p>

<pre><code>[array enumerateObjectsUsingBlock:^(NSString* obj, NSUInteger idx, BOOL *stop) {

     NSLog(@"%@",obj);
}];
NSLog(@"end");
</code></pre>

<p>}
```
枚举块的优势在于它会返回对象和索引, 而其他的枚举方法只会返回对象.</p>

<h2>并发执行</h2>

<p>现在是多核的时代，为了发挥多核的优势，在有些时候并发执行就非常具有优势。如果在枚举中有许多事要做，但并不关心枚举顺序的情况下，使用并发就很合适。 <br/>
但是对于数组总量小一些的数组，并发执行不一定会带来性能提升，反而开销可能远多于其带来的好处。<br/>
所以具体的使用需要自己进行权衡。</p>

<h3>1. 基本的并发枚举块</h3>

<p>``` objective-c
&ndash; (void) test:(NSArray*)array
{</p>

<pre><code>[array enumerateObjectsWithOptions:NSEnumerationConcurrent usingBlock:^(NSString* obj, NSUInteger idx, BOOL *stop) {

    NSLog(@"%@",obj);

}];
NSLog(@"end");
</code></pre>

<p>}
```
这种方式会为每一个枚举创建一个线程，等到所有的枚举都执行完毕才会进行下一步。</p>

<h3>2. 异步GCD并发</h3>

<p>``` objective-c
&ndash; (void) test:(NSArray*)array
{</p>

<pre><code>dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
for(NSString* test in array)
{
    dispatch_async(queue, ^{

        NSLog(@"%@",test);
    });
}
NSLog(@"end");
</code></pre>

<p>}
```
这种方式会为每一个枚举创建一个线程，但是不会等待所有枚举执行完成，而是for循环完成后就会进行下一步了，是一种异步执行的方式。</p>

<h3>3. 等待GCD并发</h3>

<p>``` objective-c
&ndash; (void) test:(NSArray*)array
{</p>

<pre><code>dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
dispatch_group_t group = dispatch_group_create();
for(NSString* test in array)
{
    dispatch_group_async(group, queue, ^{

        NSLog(@"%@",test);
    });
}
dispatch_group_wait(group, DISPATCH_TIME_FOREVER);
dispatch_release(group);
NSLog(@"end");
</code></pre>

<p>}
<code>``
这种方式使用group将多个block组成一组以监测这些Block全部完成或者等待全部完成。这种方式的效果类似于</code>1.基本的并发枚举块`。</p>

<h3>4. dispatch_apply</h3>

<p>``` objective-c
&ndash; (void) test:(NSArray*)array
{</p>

<pre><code>dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
dispatch_apply(array.count, queue, ^(size_t index){

    NSLog(@"%@",array[index]);

});
NSLog(@"end");
</code></pre>

<p>}
<code>``
这是系统提供的一种并发执行方式，这种方式的效果同样类似于</code>1.基本的并发枚举块`。</p>

<br/>


<h3>参考</h3>

<p>本文只是粗略的介绍，如果想了解更详细的使用，建议阅读下面的链接。
<a href="http://www.oschina.net/translate/high-performance-collection-looping-objective-c">http://www.oschina.net/translate/high-performance-collection-looping-objective-c</a></p>

<p><a href="http://www.dreamingwish.com/dream-2012/gcd%E4%BB%8B%E7%BB%8D%EF%BC%88%E4%BA%8C%EF%BC%89-%E5%A4%9A%E6%A0%B8%E5%BF%83%E7%9A%84%E6%80%A7%E8%83%BD.html">http://www.dreamingwish.com/dream-2012/gcd%E4%BB%8B%E7%BB%8D%EF%BC%88%E4%BA%8C%EF%BC%89-%E5%A4%9A%E6%A0%B8%E5%BF%83%E7%9A%84%E6%80%A7%E8%83%BD.html</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Objective-C枚举介绍]]></title>
    <link href="http://tmyam.github.io/blog/2014/02/24/mei-ju-jie-shao/"/>
    <updated>2014-02-24T15:39:00+08:00</updated>
    <id>http://tmyam.github.io/blog/2014/02/24/mei-ju-jie-shao</id>
    <content type="html"><![CDATA[<p>Objective-C枚举的使用，常见的方式总结，以便自己使用时方便查阅。</p>

<h2>1. 枚举介绍</h2>

<h3>enum only</h3>

<p>``` objective-c
enum
{</p>

<pre><code>TMEnumTestOne,
TMEnumTestTwo,
</code></pre>

<p>};</p>

<p>```
* 这种枚举<strong>不推荐</strong>使用，因为不能用一种类型的方式表示枚举。</p>

<!-- more -->


<h3>enum 类型</h3>

<p>``` objective-c
typedef enum
{</p>

<pre><code>TMEnumTestOne,
TMEnumTestTwo,
</code></pre>

<p>} TMEnumTest;</p>

<p><code>
</code> objective-c
enum TMEnumTest
{</p>

<pre><code>TMEnumTestOne,
TMEnumTestTwo,
</code></pre>

<p>};
typedef enum TMEnumTest TMEnumTest;</p>

<p>```
* 这两种写法，将枚举描述为一个类型<em>TMEnumTest</em>。 <br/>
但是这种写法也有局限性，在作为函数参数时，如果传入NSInteger类型的数据，则需要强制转换，否则会有类型不匹配的警告，所以这种方式也<strong>不推荐</strong>。如下图，
<img src="/images/2014/02/24/enum_warn.png" alt="temp" /></p>

<h3>老式enum写法</h3>

<p>``` objective-c
enum
{</p>

<pre><code>TMEnumTestOne,
TMEnumTestTwo,
</code></pre>

<p>};
typedef NSUInteger TMEnumTest;
```
* 这种写法可以指定<em>TMEnumTest</em>的类型，并且作为函数参数时，传入的值不需要进行强制类型转换。 <br/>
但是这种写法不会检查枚举的正确性，是好是坏需要自己判断，如下图。本人<strong>推荐</strong>这种写法。
<img src="/images/2014/02/24/enum_no_check.png" alt="temp" /></p>

<h3>新式enum写法</h3>

<p>``` objective-c
typedef NS_ENUM(NSUInteger, TMEnumTest)
{</p>

<pre><code>TMEnumTestOne,
TMEnumTestTwo,
</code></pre>

<p>};
<code>
</code> objective-c
typedef NS_OPTIONS(NSUInteger, TMEnumTest)
{</p>

<pre><code>TMEnumTestOne  = 0,
TMEnumTestTwo  = 1 &lt;&lt; 0,
</code></pre>

<p>};
```
* <strong>NS_ENUM</strong>和<strong>NS_OPTIONS</strong>本质是一样的，仅仅从字面上来区分用途。<strong>NS_ENUM</strong>是通用情况，<strong>NS_OPTIONS</strong>一般用来定义位枚举。
<a href="http://blog.csdn.net/annkie/article/details/9877643">参考链接</a> <br/>
* 这种写法同样作为函数参数时，传入的值不需要进行强制类型转换。但是也同样不会检查枚举的正确性，和 <strong>老式enum写法</strong> 一样，如下图。
<img src="/images/2014/02/24/enum_no_check.png" alt="temp" />
* 但是不同的是，<strong>新式enum写法</strong> 在使用<em>switch</em>时，会进行值的检测，如果枚举中无此值，则会弹出警告，如下图。这种方式见仁见智了。本人<strong>推荐</strong>这种写法。
<img src="/images/2014/02/24/enum_switch.png" alt="temp" /></p>

<h2>2. 枚举最大值</h2>

<p>对于一般的枚举，要获取枚举的最大值是很难的，因为随着枚举的扩充，最大值在不断变化，这时推荐使用一个固定的枚举表示最大值，例如：
``` objective-c
typedef NS_ENUM(NSUInteger, TMEnumTest)
{</p>

<pre><code>TMEnumTestOne,
TMEnumTestTwo,

TMEnumTestMax,  // 表示最大值
</code></pre>

<p>};
```
这样就可以使用<em>TMEnumTestMax</em>表示枚举<em>TMEnumTest</em>的最大值了。</p>

<h2>3. 位枚举</h2>

<p>位枚举是一种特殊的枚举，在apple的类中使用的很多，例如<code>NSStringCompareOptions</code>等。
``` objective-c
typedef NS_OPTIONS(NSUInteger, TMEnumTest)
{</p>

<pre><code>TMEnumTestOne     = 0,         // 0
TMEnumTestTwo     = 1 &lt;&lt; 0,     // 1
TMEnumTestThree   = 1 &lt;&lt; 1,     // 2
TMEnumTestFour    = 1 &lt;&lt; 2,     // 4
</code></pre>

<p>};
```</p>

<ul>
<li>位枚举的特点是可以使用位运算来处理枚举值，实际使用中可以用一个变量存储多个枚举值，表示互不影响的多个设置。
``` objective-c</li>
<li><p>(void) test
{
  TMEnumTest test = TMEnumTestTwo|TMEnumTestThree;  // 3</p>

<p>  /* 添加TMEnumTestFour到test中（如test已经包含TMEnumTestFour，则test值不变）</p>

<pre><code> 当然这里也可以使用test += TMEnumTestFour,
 但是注意 + 不能在test中已经包含TMEnumTestFour的情况下使用。
</code></pre>

<p>  */
  test |= TMEnumTestFour;  // 7</p>

<p>  /* 将TMEnumTestThree从test中去除（如test不包含TMEnumTestThree，则test值不变）</p>

<pre><code> 当然这里也可以使用test -= TMEnumTestThree，
 但是注意 - 不能在test中不包含TMEnumTestThree的情况下使用。
</code></pre>

<p>  */  <br/>
  test &amp;= ~TMEnumTestThree; // 5</p>

<p>  // 判断 TMEnumTestFour枚举 是否被包含
  if ((test &amp; TMEnumTestFour) == TMEnumTestFour)
  {
      NSLog(@&ldquo;YES&rdquo;);
  }</p>

<p>  /* 判断 TMEnumTestFour枚举 是否被包含</p>

<p>   因为 (test &amp; TMEnumTestFour) 的结果不是 0，就是TMEnumTestFour本身，
   而 TMEnumTestFour > 0 ，所以可以使用简易的判断
   */
  if (test &amp; TMEnumTestFour)
  {
      NSLog(@&ldquo;YES&rdquo;);
  }
}
```</p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mac app，创建基于文档的app]]></title>
    <link href="http://tmyam.github.io/blog/2014/02/20/chuang-jian-wen-dang-xing-ying-yong/"/>
    <updated>2014-02-20T14:24:00+08:00</updated>
    <id>http://tmyam.github.io/blog/2014/02/20/chuang-jian-wen-dang-xing-ying-yong</id>
    <content type="html"><![CDATA[<h2>简介</h2>

<p>基于文档的app在mac下又是比较常见的形式，但是介绍的文章比较少。为了避免少走弯路，在此进行一些简单的介绍。</p>

<!-- more -->


<p></p>

<h2>创建</h2>

<p>创建一个mac app，在下图这个界面，勾选<strong>Create Document-Based Application</strong> <br/>
<img src="/images/2014/02/20/create.png" alt="temp" /></p>

<p>其中继承自<strong>NSDocument</strong>的<strong>Document</strong>就是文档类，区别于<strong>AppDelegate</strong>，<strong>Document</strong>不是单例，而是对应一个个文档实例。</p>

<h2>自建文档文件图标</h2>

<p>这里省略，格式为icns&hellip;</p>

<h2>关联文件类型</h2>

<ul>
<li>导入文档图标（上步创建的图标）</li>
<li>在工程的<em>Info</em>里进行设置，如下图。 <br/>
<img src="/images/2014/02/20/info.png" alt="temp" /> <br/>
<strong>Document Types</strong>设置文档关联的文件，<em>Identifier</em>为文档标示。 <br/>
<strong>Exported UTIs</strong>为具体的文档设置，<em>Identifier</em>必须和<strong>Document Types</strong>的一致，这里面可以设置图标，扩展名等等，注意图标必须设置在<strong>Document Types</strong>里面，运行之后就会立即生效。 <br/>
而且这两项都是可以设置多个关联的，关联多个文档类，关联多种格式。</li>
</ul>


<h2>运行</h2>

<p>这时，运行工程，文件关联就已经完成了。可以创建一个指定的扩展名文件，看看是不是已经变成了指定的图标样式。如果没有改变，可以重启电脑之后看看。</p>

<h2>编码</h2>

<p>在<strong>Document.m</strong>文件里已经有两个函数。</p>

<p>``` objective-c
&ndash; (NSData <em>)dataOfType:(NSString </em>)typeName error:(NSError **)outError
{</p>

<pre><code>if ([typeName isEqualToString:@"com.tmyam.TestDocument.document"])
{
    // TODO: 这里是具体的存储文件数据
    return [@"test" dataUsingEncoding:4];
}
else
{
    if (outError)
    {
        *outError = [NSError errorWithDomain:@"TestDocumentErrorDomain"
                                        code:-1
                                    userInfo:@{NSLocalizedFailureReasonErrorKey:[NSString stringWithFormat:@"Unsupported data type: %@", typeName]}];
    }
}
return nil;
</code></pre>

<p>}</p>

<ul>
<li><p>(BOOL)readFromData:(NSData <em>)data ofType:(NSString </em>)typeName error:(NSError **)outError
{
  assert([typeName isEqualToString:@&ldquo;com.tmyam.TestDocument.document&rdquo;]);</p>

<p>  // TODO: 这里是具体的读取文件数据</p>

<p>  return YES;
}
```</p>

<h2>示例</h2>

<p><a href="/files/TestDocument.zip">TestDocument示例下载</a></p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[mac app完整的发布流程]]></title>
    <link href="http://tmyam.github.io/blog/2013/11/17/mac-app-release/"/>
    <updated>2013-11-17T10:45:00+08:00</updated>
    <id>http://tmyam.github.io/blog/2013/11/17/mac-app-release</id>
    <content type="html"><![CDATA[<p>发布mac app网上已经很多教程了，这里只是进行一个记录，有的时候容易忘记细节。</p>

<h2>前提条件</h2>

<p>1, 一个mac developer帐号</p>

<!-- more -->


<h2>创建APP ID</h2>

<ul>
<li>登陆 <a href="https://developer.apple.com/membercenter">MemberCenter</a></li>
<li>点击 <strong>Certificates, Identifiers &amp; Profiles</strong> 进入管理界面，点击<em>Identifiers</em> &ndash;> <em>App IDs</em>.</li>
</ul>


<p>通常情况下我们会创建如 <code>com.company.*</code> 这样的通用型APP ID，可以适用于大部分程序,但是对于需要推送功能，以及app内含有其他app的程序，这样的ID就不行了。保险起见还是创建单独的APP ID。</p>

<ul>
<li>点击<code>+</code> 按钮，进入创建页面。 <br/>
<em>App ID Description</em> 就是一个名称，随意输入就行，不做他用。 <br/>
<em>App Services</em> 应用将具有的能力，可以根据需要勾选。 <br/>
<em>App ID Prefix</em> 标示前缀，不用管。 <br/>
<em>App ID Suffix</em> 标示后缀，这里有两种选择 <strong>Explicit App ID</strong>这种就是一对一的ID，而<strong>Wildcard App ID</strong> 这种就是上面提到的一对多的ID。 <br/>
这里创建 <strong>Explicit App ID</strong> ，<em>Bundle ID:</em> 为类似 <code>com.company.xxx</code>这种样式，<code>company</code>为公司名，<code>xxx</code>为应用程序名，注意大小写一致。 <br/>
一路继续，创建成功。</li>
</ul>


<h2>在iTunes Connect添加App</h2>

<p>这一步需要在开始开发之前做，因为App Name可能已经被别的人占用了，一旦做完应用才创建，不得不面临改名的困境，所以在开发前先将应用名占着。（但是这也有一定风险，如果半年内没有提交该应用，那么你就永远用不了这个名字了&hellip;）</p>

<p><a href="http://my.oschina.net/joanfen/blog/133642">参考链接</a></p>

<ul>
<li>通过<a href="https://developer.apple.com/membercenter">MemberCenter</a> 点击进入<strong>iTunes Connect</strong>，这样可以使创建的ID快速生效。</li>
<li>点击 <strong>Manage Your Apps</strong>,然后点击<code>Add New App</code>按钮。</li>
</ul>


<p>然后是填写<strong>App Information</strong></p>

<ul>
<li>其中<em>SKU Number</em> 是区分你自己应用的标示，只要不重复就行，这里填写和App Name一样就行了。</li>
<li><em>Bundle ID</em> 选择之前创建的ID，然后继续。</li>
</ul>


<p>之后是选择价格界面，选择之后点击继续。</p>

<p> 最后是应用详细信息。</p>

<ul>
<li><p><strong>Version Information</strong> <br/>
 <em>Version Number</em>  版本号 <br/>
 <em>Copyright</em>  版权，填写<code>2013-2014 company Inc</code> 就可以了。</p></li>
<li><p><strong>Category</strong>（app种类） <br/>
选择app所属的两种类型。</p></li>
<li><p><strong>Rating</strong>（分级） <br/>
一般根据情况选择，没有就全选<em>None</em>。</p></li>
<li><p><strong>Metadata</strong>（软件信息） <br/>
根据需要填写，也可以之后再更改。</p></li>
<li><p><strong>Contact Information</strong> <br/>
根据实际情况填写。</p></li>
<li><p><strong>Uploads</strong>（截图） <br/>
可以先选张上去，之后再更改。</p></li>
</ul>


<p>至此，开放前的准备工作就完成了。</p>

<h2>生成发布的描述文件</h2>

<p>在编写程序的时候需要对沙箱环境进行测试，这里使用通用的Mac developer证书，以及通用的描述文件即可达到目的。但是发布的话还需要专用的描述文件。</p>

<p><a href="http://my.oschina.net/joanfen/blog/133624">参考链接</a></p>

<ul>
<li><p>登陆 <a href="https://developer.apple.com/membercenter">MemberCenter</a></p></li>
<li><p>点击 <strong>Certificates, Identifiers &amp; Profiles</strong> 进入管理界面，点击<em>Identifiers</em> &ndash;> <em>Provisioning Profiles</em> &ndash;> <em>Distribution</em>, 点击 <code>+</code> 按钮。</p></li>
<li><p>根据提示一步一步前进，<em>Profile Name:</em>可以使用 <code>AppNameProfile</code>的样式，最后点击生成。</p></li>
<li><p>下载生成的描述文件，右键用Xcode打开，然后在工程中选择 <strong>3rd Party Mac Developer Application:&hellip;</strong> 的证书及对应的描述文件。如下图 <br/>
<img src="/images/2013/11/18/code_sign.png" alt="temp" /></p></li>
</ul>


<h2>编写程序&hellip;</h2>

<p>这里不多赘述了&hellip;</p>

<h2>发布</h2>

<p>程序写好，测试完成就可以发布了。
还记得在 <strong>iTunes Connect</strong> 添加的app吗，现在可以进行完善工作了。 <br/>
目前状态 <strong>Prepare for Upload</strong></p>

<ul>
<li><p>对 <em>Description</em> 和 <em>Screenshots</em> 重写填写和上传新的截图，并保存。全部改完后点击<code>Ready to Upload Binary</code>。</p></li>
<li><p><em>Export Compliance</em> 的提问选择 NO 就可以了。之后继续进入 <strong>Waiting For Upload</strong> 状态。</p></li>
<li><p>回到Xcode工程，选择菜单 <em>Product</em> &ndash;> <em>Archive</em>,进入 Organizer 的 Archives 界面。</p></li>
<li><p>选择<code>validate...</code>按钮验证app是否能通过验证。 <br/>
这步是最容易发现错误的地方，错误的种类也多种多样，根据实际的错误自己修改吧。</p></li>
<li><p>如果没有错误，完成之后点击<code>Distribute...</code>按钮，等待一段漫长的上传之后，回到<strong>iTunes Connect</strong>，状态变成了 <strong>Upload Received</strong>。</p></li>
<li><p>等待一段时间，机器会进行初步审核，成功后状态会变成 <strong>Waiting For Review</strong> ，失败的话有具体的提示。</p></li>
<li><p>之后就是等待人工审核了，这里只有等了，一般2~10天不等，升级会快一些。如果想取消发布，可以点击 <strong>Binary Details</strong> ，在新页面点击右上角的 <code>Reject This Binary</code>按钮。</p></li>
<li><p>漫长的等待之后，状态会变成 <strong>In Review</strong>，如果不顺利，那么又要从头开始上传，接着是漫长的等待&hellip; <br/>
如果顺利，状态之后会变成 <strong>Processing for App Store</strong>，最后是 <strong>Ready for Sale</strong>，至此发布完成。</p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[mac app开发中添加第三方framework]]></title>
    <link href="http://tmyam.github.io/blog/2013/11/05/mac-develop-add-framework/"/>
    <updated>2013-11-05T15:23:00+08:00</updated>
    <id>http://tmyam.github.io/blog/2013/11/05/mac-develop-add-framework</id>
    <content type="html"><![CDATA[<p>环境: <code>(mac 版本 10.9 ) ( Xcode 5.0 )</code></p>

<hr />

<br/>


<h4>步骤很简单，但是总是忘记，所以在这里做个记录。</h4>

<ul>
<li>在工程目录中建个文件夹，存放将要添加的第三方framework</li>
</ul>


<!-- more -->


<ul>
<li><p>在工程的 <em>Build Phases</em> 栏点击菜单，如下图，添加 <em>Copy Files</em><br/>
<img src="/images/2013/11/05/add_copy_files.png" alt="temp" /></p></li>
<li><p>选择<code>Frameworks</code>,点击<code>+</code>号，然后找到存放第三方framework的文件夹，选择要添加的framework，如下图<br/>
<img src="/images/2013/11/05/add_framework.png" alt="temp" /></p></li>
<li><p>展开<em>Link Binary With Libraries</em> 点击<code>+</code>号，同上一步一样，找到找到存放第三方framework的文件夹，选择要使用的framework，如下图<br/>
<img src="/images/2013/11/05/use_framework.png" alt="temp" /></p></li>
</ul>


<p>右侧的文件管理里，刚添加的framework会位于顶端，可以稍作整理，移动到Frameworks组里，这时添加就完成了可以随意使用了。</p>

<h4>修改关联路径</h4>

<p>一般情况下，如果将framework文件放到了工程文件夹的里面，那么在移动工程文件夹后，编译工程会出现无法找到framework头文件的错误，这是因为工程默认添加的路径使用了绝对路径的关系。</p>

<ul>
<li>修改 <br/>
在Xcode的 <em>Build Settings</em> 里找到 <em>Framework Search Paths</em> 栏，修改参数为 <br/>
$(SRCROOT)/<code>当前工程名</code>/<code>第三方framework所在的文件夹</code> <br/>
例如：
<img src="/images/2013/11/05/change_path_framework.png" alt="temp" />
这样就算移动工程文件夹，也不会报错了。</li>
</ul>


<h4>清除冗余文件</h4>

<p>对于已经添加的第三方framework，在生成的app中可以查看到framework的头文件，出于两个目的的考虑。<br/>
1. 由于程序中已经引入了这些头文件，所以重复添加浪费了空间。<br/>
2. 出于安全性的考虑，防止被别人使用或者破解。</p>

<p><strong>清除方法：</strong></p>

<ul>
<li><p>在工程的 <em>Build Phases</em> 栏点击菜单，入最上面的图里，这次添加 <em>Run Script</em><br/>
<img src="/images/2013/11/05/add_copy_files.png" alt="temp" /></p></li>
<li><p>贴入如下代码</p></li>
</ul>


<p><code>sh
echo "build path ${TARGET_BUILD_DIR}"  
cd ${TARGET_BUILD_DIR}/${FULL_PRODUCT_NAME}/Contents/Frameworks   
rm -rf */Headers   
rm -rf */Versions/*/Headers
rm -rf */Versions/*/Resources/*/Contents/Headers
rm -rf */PrivateHeaders
rm -rf */Versions/*/PrivateHeaders
rm -rf */Versions/*/Resources/*/Contents/PrivateHeaders
</code><br/>
如下图 <br/>
<img src="/images/2013/11/05/clean_framework.png" alt="temp" /></p>

<h4>编译问题</h4>

<p>对于编译出现签名错误的问题，可以查看<a href="http://tmyam.github.io/blog/2013/11/05/xcode5-mac-app-running-on-lion/">链接</a>。</p>

<blockquote><p>/Users/…/xxx.app: code object is not signed at all In subcomponent: /Users/…/xxx.app/Contents/Frameworks/xxx.framework Command /usr/bin/codesign failed with exit code 1</p></blockquote>

<hr />

<br/>


<p><strong>另外，由于framework中含有文件夹的快捷方式，在使用svn等版本管理软件时，新checkout的framework中的快捷方式会丢失，虽然编译运行没有问题，但是提交到mac appstore时无法通过，所以需要注意做压缩备份。</strong></p>
]]></content>
  </entry>
  
</feed>
