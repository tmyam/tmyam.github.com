<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: mac_develop | tmyam's blog]]></title>
  <link href="http://tmyam.github.io/blog/categories/mac-develop/atom.xml" rel="self"/>
  <link href="http://tmyam.github.io/"/>
  <updated>2014-06-10T16:49:38+08:00</updated>
  <id>http://tmyam.github.io/</id>
  <author>
    <name><![CDATA[tmyam]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[mac app的开机自启动]]></title>
    <link href="http://tmyam.github.io/blog/2014/06/10/sha-he-kai-ji-zi-qi-dong/"/>
    <updated>2014-06-10T14:15:00+08:00</updated>
    <id>http://tmyam.github.io/blog/2014/06/10/sha-he-kai-ji-zi-qi-dong</id>
    <content type="html"><![CDATA[<h2>前言</h2>

<p>在出现沙盒以前，mac下设置开机自启动是很容易的，使用 LSSharedFileListRef 很容易做到开机自启动。但自从沙盒出现之后，就变得麻烦了点，这里进行一下详细的使用描述。</p>

<h2>非沙盒下的开机自启动</h2>

<p>简单的说只需要两个函数就可以了。而且这种开机自启动和app所在的文件夹无关，并且可以在"系统偏好设置"&ndash;>&ldquo;用户与群组&rdquo;&ndash;>&ldquo;登录项"里面看到，并进行设置。</p>

<!-- more -->


<p></p>

<p>``` objective-c
+ (BOOL) isStartAtLogin
{</p>

<pre><code>BOOL  isHaveAdd = NO;
NSString* appPath = [[NSBundle mainBundle] bundlePath];
LSSharedFileListRef loginItems = LSSharedFileListCreate(NULL, kLSSharedFileListSessionLoginItems, NULL);
UInt32 seedValue = 0;
NSArray* loginItemsArray = (NSArray*)LSSharedFileListCopySnapshot(loginItems, &amp;seedValue);
CFURLRef tempUrl = (CFURLRef)[NSURL fileURLWithPath:appPath];
for(NSInteger i = 0 ; i&lt; [loginItemsArray count]; i ++ )
{
    LSSharedFileListItemRef itemRef = (LSSharedFileListItemRef)[loginItemsArray objectAtIndex:i];
    if (LSSharedFileListItemResolve(itemRef, 0,&amp;tempUrl, NULL) == noErr)
    {
        NSString * urlPath = [(NSURL*)tempUrl path];
        if ([urlPath compare:appPath] == NSOrderedSame)
        {
            isHaveAdd = YES;
            break;
        }
    }
}
[loginItemsArray release];
CFRelease(loginItems);
return isHaveAdd;
</code></pre>

<p>}</p>

<ul>
<li>(BOOL) setStartAtLogin:(BOOL)startAtLogin
{
  NSString<em> appPath = [[NSBundle mainBundle] bundlePath];
  BOOL result = NO;
  if (startAtLogin)
  {
      if (![self isStartAtLogin])
      {
          CFURLRef url = (CFURLRef)[NSURL fileURLWithPath:appPath];
          LSSharedFileListRef newloginItems = LSSharedFileListCreate(NULL, kLSSharedFileListSessionLoginItems, NULL);
          LSSharedFileListItemRef item = LSSharedFileListInsertItemURL(newloginItems, kLSSharedFileListItemLast, NULL, NULL, url, NULL, NULL);
          if (item)
          {
              result = YES;
              CFRelease(item);
          }
          if (newloginItems)
          {
              CFRelease(newloginItems);
          }
      }
  }
  else
  {
      LSSharedFileListRef loginItems = LSSharedFileListCreate(NULL,kLSSharedFileListSessionLoginItems, NULL);
      UInt32 seedValue = 0;
      NSArray</em> loginItemsArray = (NSArray<em>)LSSharedFileListCopySnapshot(loginItems, &amp;seedValue);
      CFURLRef tempUrl = (CFURLRef)[NSURL fileURLWithPath:appPath];
      for(NSInteger i = 0 ; i &lt; [loginItemsArray count]; i ++ )
      {
          LSSharedFileListItemRef itemRef = (LSSharedFileListItemRef)[loginItemsArray objectAtIndex:i];
          if (LSSharedFileListItemResolve(itemRef, 0,&amp;tempUrl, NULL) == noErr)
          {
              NSString * urlPath = [(NSURL</em>)tempUrl path];
              if ([urlPath compare:appPath] == NSOrderedSame)
              {
                  OSStatus status = LSSharedFileListItemRemove(loginItems,itemRef);
                  result = (status == noErr);
              }
          }
      }
      [loginItemsArray release];
      CFRelease(loginItems);
  }
  return result;
}
```</li>
</ul>


<h2>沙盒下的开机自启动</h2>

<p>沙盒下的自启动会比较麻烦，步骤比较多。这里以程序 test 为例，进行详细阐述。</p>

<h3>1. 添加Helper程序</h3>

<p>沙盒下，app是无法自己做到开机自启动的，需要另外一个app协助才行。这里就创建这样一个app，为了便于区分起名testHelper。
<img src="/images/2014/06/10/01.jpg" alt="temp" /></p>

<h3>2. 设置Helper</h3>

<p>test和testHelper都需要设置，这里先进行testHelper的设置.</p>

<ul>
<li>修改build Configuration 为 Release 。
<img src="/images/2014/06/10/02.jpg" alt="temp" /></li>
<li>修改Info.plist文件，使app在运行时不显示到前端。
<img src="/images/2014/06/10/03.jpg" alt="temp" /></li>
<li>删除MainMenu.xib中的window窗口，  <br/>
并且删除 AppDelegate.h 中的<code>@property (assign) IBOutlet NSWindow *window;</code>。  <br/>
这些都是确保app在运行时不显示到前端。
<img src="/images/2014/06/10/04.jpg" alt="temp" /></li>
<li>修改 Build Settings 的 <strong>Skip Install</strong> 为 YES。
<img src="/images/2014/06/10/05.jpg" alt="temp" /></li>
<li>设置沙盒环境，证书，描述文件。  <br/>
这里设置的发布证书，如果需要测试，可以设置开发者证书进行测试。
<img src="/images/2014/06/10/06.jpg" alt="temp" /></li>
</ul>


<h3>3. 添加Helper的代码</h3>

<p>参照下面的函数，复制到testHelper的AppDelegate中，注意修改identifier和appName为自己主app的信息。这段代码的意义是启动主app。</p>

<p>``` objective-c
&ndash; (void)applicationDidFinishLaunching:(NSNotification *)aNotification
{</p>

<pre><code>[self runMainApp:@"com.tmyam.test" appName:@"test"];
</code></pre>

<p>}</p>

<p>/** 运行开机自启动的app</p>

<p> @param identifier 主app的标识符
 @param appName 主app的名称（在MacOS文件夹下的名称）
 <em>/
&ndash; (void) runMainApp:(NSString</em>)identifier appName:(NSString*)appName
{</p>

<pre><code>// Check if main app is already running; if yes, do nothing and terminate helper app
BOOL alreadyRunning = NO;
NSArray *running = [[NSWorkspace sharedWorkspace] runningApplications];
for (NSRunningApplication *app in running)
{
    if ([[app bundleIdentifier] isEqualToString:identifier])
    {
        alreadyRunning = YES;
    }
}
if (!alreadyRunning)
{
    NSString *path = [[NSBundle mainBundle] bundlePath];
    NSArray *p = [path pathComponents];
    NSMutableArray *pathComponents = [NSMutableArray arrayWithArray:p];
    [pathComponents removeLastObject];
    [pathComponents removeLastObject];
    [pathComponents removeLastObject];
    [pathComponents addObject:@"MacOS"];
    [pathComponents addObject:appName];
    NSString *newPath = [NSString pathWithComponents:pathComponents];
    [[NSWorkspace sharedWorkspace] launchApplication:newPath];
}
[NSApp terminate:nil];
</code></pre>

<p>}
```</p>

<h3>4. 设置主程序</h3>

<ul>
<li>test添加Copy Files 。
<img src="/images/2014/06/10/07.jpg" alt="temp" /></li>
<li>设置 Copy Files 。Destination为"Wrapper"，Subpath为"Contents/Library/LoginItems"，添加"testHelper.app"如下图。 <br/>
<img src="/images/2014/06/10/08.jpg" alt="temp" /></li>
<li>设置依赖，如下图。<br/>
<img src="/images/2014/06/10/09.jpg" alt="temp" /></li>
<li>设置 Build Settings &ndash;> &ldquo;Strip Debug Symbols During Copy&rdquo; 为 NO 。
<img src="/images/2014/06/10/10.jpg" alt="temp" /></li>
<li>设置沙盒环境，证书，描述文件。  <br/>
这里设置的发布证书，如果需要测试，可以设置开发者证书进行测试。
<img src="/images/2014/06/10/11.jpg" alt="temp" /></li>
</ul>


<h3>5. 主程序添加代码</h3>

<ul>
<li><p>test首先导入两个文件，StartAtLoginController.h和StartAtLoginController.m，<a href="/files/StartAtLoginController.zip">StartAtLoginController下载</a></p></li>
<li><p>添加 ServiceManagement.framework
<img src="/images/2014/06/10/12.jpg" alt="temp" /></p></li>
<li><p>创建一个管理文件例如 TMStartAtLogin，负责管理开机自启动状态，并在里面粘贴以下代码。   <br/>
别忘了 #import &ldquo;StartAtLoginController.h&rdquo;  <br/>
这里的 Identifier是testHelper的标识符。</p></li>
</ul>


<p>``` objective-c
+ (BOOL) isStartAtLogin
{</p>

<pre><code>StartAtLoginController* loginController = [[StartAtLoginController alloc]initWithIdentifier:@"com.tmyam.testHelper"];
BOOL startedAtLogin = [loginController startAtLogin];
[loginController release];
return startedAtLogin;
</code></pre>

<p>}</p>

<ul>
<li>(BOOL) setStartAtLogin:(BOOL)isStartLogin
{
  StartAtLoginController* loginController = [[StartAtLoginController alloc]initWithIdentifier:@&ldquo;com.tmyam.testHelper&rdquo;];
  loginController.startAtLogin = isStartLogin;
  BOOL result = loginController.enabled;
  [loginController release];
  return result;
}
```

<h3>结尾</h3>

<p>至此，所有的设置已经完成，可以通过主程序的 TMStartAtLogin 管理自启动的状态。
还有要注意的地方，如果要测试沙盒下的开机自启动，<strong>需要将编译出的app放入系统的应用程序目录下</strong>，否则不会生效。</p></li>
</ul>


<p>另外，在发布app时，会遇到因为使用了testHelper证书而导致上传到app store时的错误，这时需要深入到<em>&ldquo;&hellip;/Products/Applications/test.app/Contents/Library/LoginItems/testHelper.app/Contents&rdquo;</em>目录下，删除embedded.provisionprofile文件，就可以正确上传了。</p>

<h2>示例</h2>

<p><a href="/files/StartAtLoginController.zip">StartAtLoginController下载</a> <br/>
<a href="/files/test-startatlogin.zip">test示例下载</a></p>

<h2>参考</h2>

<p><a href="http://blog.timschroeder.net/2012/07/03/the-launch-at-login-sandbox-project/">http://blog.timschroeder.net/2012/07/03/the-launch-at-login-sandbox-project/</a>
<a href="http://stackoverflow.com/questions/11230168/submit-an-osx-app-with-helper-app-in-its-bundle">http://stackoverflow.com/questions/11230168/submit-an-osx-app-with-helper-app-in-its-bundle</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mac app，创建基于文档的app]]></title>
    <link href="http://tmyam.github.io/blog/2014/02/20/chuang-jian-wen-dang-xing-ying-yong/"/>
    <updated>2014-02-20T14:24:00+08:00</updated>
    <id>http://tmyam.github.io/blog/2014/02/20/chuang-jian-wen-dang-xing-ying-yong</id>
    <content type="html"><![CDATA[<h2>简介</h2>

<p>基于文档的app在mac下又是比较常见的形式，但是介绍的文章比较少。为了避免少走弯路，在此进行一些简单的介绍。</p>

<!-- more -->


<p></p>

<h2>创建</h2>

<p>创建一个mac app，在下图这个界面，勾选<strong>Create Document-Based Application</strong> <br/>
<img src="/images/2014/02/20/create.png" alt="temp" /></p>

<p>其中继承自<strong>NSDocument</strong>的<strong>Document</strong>就是文档类，区别于<strong>AppDelegate</strong>，<strong>Document</strong>不是单例，而是对应一个个文档实例。</p>

<h2>自建文档文件图标</h2>

<p>这里省略，格式为icns&hellip;</p>

<h2>关联文件类型</h2>

<ul>
<li>导入文档图标（上步创建的图标）</li>
<li>在工程的<em>Info</em>里进行设置，如下图。 <br/>
<img src="/images/2014/02/20/info.png" alt="temp" /> <br/>
<strong>Document Types</strong>设置文档关联的文件，<em>Identifier</em>为文档标示。 <br/>
<strong>Exported UTIs</strong>为具体的文档设置，<em>Identifier</em>必须和<strong>Document Types</strong>的一致，这里面可以设置图标，扩展名等等。 <br/>
注意图标必须设置在<strong>Document Types</strong>里面，运行之后就会立即生效。 <br/>
而且这两项都是可以设置多个关联的，关联多个文档类，关联多种格式。</li>
</ul>


<h2>运行</h2>

<p>这时，运行工程，文件关联就已经完成了。可以创建一个指定的扩展名文件，看看是不是已经变成了指定的图标样式。如果没有改变，可以重启电脑之后看看。</p>

<h2>编码</h2>

<p>在<strong>Document.m</strong>文件里已经有两个函数。</p>

<p>``` objective-c
&ndash; (NSData <em>)dataOfType:(NSString </em>)typeName error:(NSError **)outError
{</p>

<pre><code>if ([typeName isEqualToString:@"com.tmyam.TestDocument.document"])
{
    // TODO: 这里是具体的存储文件数据
    return [@"test" dataUsingEncoding:4];
}
else
{
    if (outError)
    {
        *outError = [NSError errorWithDomain:@"TestDocumentErrorDomain"
                                        code:-1
                                    userInfo:@{NSLocalizedFailureReasonErrorKey:[NSString stringWithFormat:@"Unsupported data type: %@", typeName]}];
    }
}
return nil;
</code></pre>

<p>}</p>

<ul>
<li><p>(BOOL)readFromData:(NSData <em>)data ofType:(NSString </em>)typeName error:(NSError **)outError
{
  assert([typeName isEqualToString:@&ldquo;com.tmyam.TestDocument.document&rdquo;]);</p>

<p>  // TODO: 这里是具体的读取文件数据</p>

<p>  return YES;
}
```</p>

<h2>示例</h2>

<p><a href="/files/TestDocument.zip">TestDocument示例下载</a></p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[mac app开发中添加第三方framework]]></title>
    <link href="http://tmyam.github.io/blog/2013/11/05/mac-develop-add-framework/"/>
    <updated>2013-11-05T15:23:00+08:00</updated>
    <id>http://tmyam.github.io/blog/2013/11/05/mac-develop-add-framework</id>
    <content type="html"><![CDATA[<p>环境: <code>(mac 版本 10.9 ) ( Xcode 5.0 )</code></p>

<hr />

<br/>


<h4>步骤很简单，但是总是忘记，所以在这里做个记录。</h4>

<ul>
<li>在工程目录中建个文件夹，存放将要添加的第三方framework</li>
</ul>


<!-- more -->


<ul>
<li><p>在工程的 <em>Build Phases</em> 栏点击菜单，如下图，添加 <em>Copy Files</em><br/>
<img src="/images/2013/11/05/add_copy_files.png" alt="temp" /></p></li>
<li><p>选择<code>Frameworks</code>,点击<code>+</code>号，然后找到存放第三方framework的文件夹，选择要添加的framework，如下图<br/>
<img src="/images/2013/11/05/add_framework.png" alt="temp" /></p></li>
<li><p>展开<em>Link Binary With Libraries</em> 点击<code>+</code>号，同上一步一样，找到找到存放第三方framework的文件夹，选择要使用的framework，如下图<br/>
<img src="/images/2013/11/05/use_framework.png" alt="temp" /></p></li>
</ul>


<p>右侧的文件管理里，刚添加的framework会位于顶端，可以稍作整理，移动到Frameworks组里，这时添加就完成了可以随意使用了。</p>

<h4>修改关联路径</h4>

<p>一般情况下，如果将framework文件放到了工程文件夹的里面，那么在移动工程文件夹后，编译工程会出现无法找到framework头文件的错误，这是因为工程默认添加的路径使用了绝对路径的关系。</p>

<ul>
<li>修改 <br/>
在Xcode的 <em>Build Settings</em> 里找到 <em>Framework Search Paths</em> 栏，修改参数为 <br/>
$(SRCROOT)/<code>当前工程名</code>/<code>第三方framework所在的文件夹</code> <br/>
例如：
<img src="/images/2013/11/05/change_path_framework.png" alt="temp" />
这样就算移动工程文件夹，也不会报错了。</li>
</ul>


<h4>清除冗余文件</h4>

<p>对于已经添加的第三方framework，在生成的app中可以查看到framework的头文件，出于两个目的的考虑。<br/>
1. 由于程序中已经引入了这些头文件，所以重复添加浪费了空间。<br/>
2. 出于安全性的考虑，防止被别人使用或者破解。</p>

<p><strong>清除方法：</strong></p>

<ul>
<li><p>在工程的 <em>Build Phases</em> 栏点击菜单，入最上面的图里，这次添加 <em>Run Script</em><br/>
<img src="/images/2013/11/05/add_copy_files.png" alt="temp" /></p></li>
<li><p>贴入如下代码</p></li>
</ul>


<p><code>sh
echo "build path ${TARGET_BUILD_DIR}"  
cd ${TARGET_BUILD_DIR}/${FULL_PRODUCT_NAME}/Contents/Frameworks   
rm -rf */Headers   
rm -rf */Versions/*/Headers
rm -rf */Versions/*/Resources/*/Contents/Headers
rm -rf */PrivateHeaders
rm -rf */Versions/*/PrivateHeaders
rm -rf */Versions/*/Resources/*/Contents/PrivateHeaders
</code><br/>
如下图 <br/>
<img src="/images/2013/11/05/clean_framework.png" alt="temp" /></p>

<h4>编译问题</h4>

<p>对于编译出现签名错误的问题，可以查看<a href="http://tmyam.github.io/blog/2013/11/05/xcode5-mac-app-running-on-lion/">链接</a>。</p>

<blockquote><p>/Users/…/xxx.app: code object is not signed at all In subcomponent: /Users/…/xxx.app/Contents/Frameworks/xxx.framework Command /usr/bin/codesign failed with exit code 1</p></blockquote>

<hr />

<br/>


<p><strong>另外，由于framework中含有文件夹的快捷方式，在使用svn等版本管理软件时，新checkout的framework中的快捷方式会丢失，虽然编译运行没有问题，但是提交到mac appstore时无法通过，所以需要注意做压缩备份。</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Xcode 5.0在Mavericks下创建的mac app在Lion下无法运行的问题]]></title>
    <link href="http://tmyam.github.io/blog/2013/11/05/xcode5-mac-app-running-on-lion/"/>
    <updated>2013-11-05T10:05:00+08:00</updated>
    <id>http://tmyam.github.io/blog/2013/11/05/xcode5-mac-app-running-on-lion</id>
    <content type="html"><![CDATA[<h2>前因</h2>

<p>最近mac操作系统升级到了Mavericks(10.9)，编程工具Xcode也升级到了5.0，但是升级之后问题多多。
先是以前创建的mac app工程使用到第三方framework的地方，无法编译通过了，其次就是编译出的程序在Lion(10.7)系统下无法运行了，要做兼容的话，真是让人头疼。</p>

<!-- more -->


<h2>解决</h2>

<h3>引用第三方framework</h3>

<p>原本mac app开发使用的第三方framework是不需要签名的，但是系统升级到Mavericks，Xcode升级到5.0后，再引用无签名的第三方framework时就无法编译通过了，这对于使用资源是很不利的。</p>

<blockquote><p>/Users/&hellip;/xxx.app: code object is not signed at all
In subcomponent: /Users/&hellip;/xxx.app/Contents/Frameworks/xxx.framework
Command /usr/bin/codesign failed with exit code 1</p></blockquote>

<p>解决方案：</p>

<ul>
<li><p>方案1: 这个问题只出现在Mavericks + Xcode5.0下面，可能是一个系统bug，所以可以选择降系统。（比较麻烦）</p></li>
<li><p>方案2: 可以找到第三方framework的开源文件，自己使用签名进行编译。（不够通用）</p></li>
<li><p>方案3: 在工程的 <code>Other Code Signing Flags</code> 栏加入 <code>--deep</code> 给第三方framework签名。<a href="http://support.hockeyapp.net/discussions/problems/14709-code-sign-error-in-xcode-501-for-os-x-target">参考链接</a></p></li>
</ul>


<h3>Lion(10.7)的兼容</h3>

<p>Mavericks(10.9) + Xcode5.0创建的mac app程序无法在Lion(10.7)上面运行，就算选择了tag为10.7也不行。<br/>
究其原因发现，新创建的程序下面多了个 <em>Base.lproj</em> 文件夹，<em>MainMenu.xib</em> 文件就在里面，而在以前，<em>MainMenu.xib</em> 文件是在 <em>en.lproj</em> 文件夹下的。</p>

<p>而且系统也有相应的提示</p>

<blockquote><p>warning: Internationalization of /Users/&hellip;/Base.lproj/MainMenu.xib is not available when compiling for targets before Mac OS X 10.8</p></blockquote>

<ul>
<li>修改很简单，点击<em>MainMenu.xib</em>，找到如下图的位置，点击 <code>Base</code><br/>
<img src="/images/2013/11/05/xib_change.png" alt="temp" /><br/>
之后弹出对话框，如下图，点击 <code>Move</code>
<img src="/images/2013/11/05/xib_move.png" alt="temp" /> <br/>
工程中的<code>Base.lproj</code>文件夹已经没有用了，可以选择删除。</li>
</ul>


<p>这样编译出的app就可以兼容Lion(10.7)了。</p>
]]></content>
  </entry>
  
</feed>
