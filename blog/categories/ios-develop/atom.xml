<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ios_develop | tmyam's blog]]></title>
  <link href="http://tmyam.github.io/blog/categories/ios-develop/atom.xml" rel="self"/>
  <link href="http://tmyam.github.io/"/>
  <updated>2014-03-09T21:37:31+08:00</updated>
  <id>http://tmyam.github.io/</id>
  <author>
    <name><![CDATA[tmyam]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[iDP申请[转载]]]></title>
    <link href="http://tmyam.github.io/blog/2014/03/09/idpshen-qing/"/>
    <updated>2014-03-09T20:06:00+08:00</updated>
    <id>http://tmyam.github.io/blog/2014/03/09/idpshen-qing</id>
    <content type="html"><![CDATA[<h2>前言</h2>

<p>当初我申请idp的一篇详细的文章，不过现在里面的图都挂了，我费了点劲才找回这些图，在这里进行一下还原，希望能帮到需要的人。</p>

<h2>正文</h2>

<p>我的iDP之路04——iDP申请,如何花出去$99,2011年6月份版 <br/>
这帖子本来应该是六月份写的，怎奈那时期末将近，小弟我搞App刚刚起步，资金全靠奖学金维持，不得不投入到准备考试的深渊中。放假期间被我娘她老人家逼着学车，第一个App搞得很是不顺。这个帖子只能一拖再拖。废话稍候再罗嗦，下面是图和解说：</p>

<!-- more -->


<h5>1</h5>

<p><img src="/images/2014/03/09/01.png" alt="temp" />
我是从申请过developer开始的。Apple id和developer太简单了，就不说了，不过填信息也不能乱填，下面说。这张图是登入developer的画面。</p>

<h5>2</h5>

<p><img src="/images/2014/03/09/02.png" alt="temp" /></p>

<h5>3</h5>

<p><img src="/images/2014/03/09/03.png" alt="temp" /></p>

<h5>4</h5>

<p><img src="/images/2014/03/09/04.png" alt="temp" />
因为已经注册过Apple id和developer了，所以我选的是红圈那项。</p>

<h5>5</h5>

<p><img src="/images/2014/03/09/05.png" alt="temp" />
左边是个人，右边是团队。我光杆司令一个，所以选了左边。</p>

<h5>6</h5>

<p><img src="/images/2014/03/09/06.png" alt="temp" />
不知是不是cookie过期了，到了这里要重新登录一次。</p>

<h5>7</h5>

<p><img src="/images/2014/03/09/07.png" alt="temp" />
这里的信息是信用卡(借记卡可不行)的信息：我(假如叫<strong>王五</strong>)所有名字顺序，除了在银行流留的是中英文<strong>王五</strong>，apple的各种页面上都是英文<strong>Wu Wang</strong>。</p>

<h5>8</h5>

<p><img src="/images/2014/03/09/08.png" alt="temp" />
这里奉上英文的地址写法一例： <br/>
Mailbox 166,Nankai University,94 WeijinRd,Nankai District,Tianjin 300072.  <br/>
这个页面上  <br/>
Street Address: Mailbox 166,Nankai University  <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;94 WeijinRd,Nankai District,Tianjin  <br/>
Postal Code: 300072  <br/>
Phone: 86 &ndash; 411 &ndash; 手机号</p>

<h5>9</h5>

<p><img src="/images/2014/03/09/09.png" alt="temp" /></p>

<h5>10</h5>

<p><img src="/images/2014/03/09/10.png" alt="temp" />
上面提到过developer申请时信息不能乱写。这图上面的信息就是从那里映射过来的，你可以看到地址有些出入，不过还好影响不大。各位填写时应尽量保持一致。</p>

<h5>11</h5>

<p><img src="/images/2014/03/09/11.png" alt="temp" />
这张表下下来，用PS填写各种信息，大部分是银行信息。</p>

<h5>12</h5>

<p><img src="/images/2014/03/09/12.png" alt="temp" />
这份邮件曾经让我望眼欲穿，等了5天吧，给亚洲苹果去了3个电话，发了3封邮件。亚洲苹果普通话服务真不是普通话&hellip;总之，把上图的<strong>Purchase Form</strong> PS完，我存成jpg发给了
<font color=red><a href="&#x6d;&#x61;&#105;&#108;&#116;&#x6f;&#58;&#99;&#104;&#x69;&#x6e;&#x61;&#100;&#x65;&#118;&#64;&#97;&#x73;&#105;&#97;&#x2e;&#97;&#x70;&#112;&#108;&#101;&#x2e;&#x63;&#111;&#x6d;">&#x63;&#x68;&#105;&#x6e;&#x61;&#x64;&#101;&#118;&#x40;&#x61;&#x73;&#105;&#97;&#x2e;&#x61;&#112;&#x70;&#x6c;&#x65;&#x2e;&#99;&#111;&#x6d;</a></font>。
就可以等了，不过论坛里各位前辈的经验是打电话啊发邮件啊地催。我发邮件是因为地址因为笔误写错了。</p>

<h5>13</h5>

<p><img src="/images/2014/03/09/13.png" alt="temp" />
收到上图邮件后就能进ituesconnect.apple.com了，进contract，tax，and banking，就能看到上图。上面的是可以申请的合同，下面是已经生效的。因为免费app合同不用申请进进来就在下面了。</p>

<h5>14</h5>

<p><img src="/images/2014/03/09/14.png" alt="temp" /></p>

<h5>15</h5>

<p><img src="/images/2014/03/09/15.png" alt="temp" /></p>

<h5>16</h5>

<p><img src="/images/2014/03/09/16.png" alt="temp" />
红圈子里是需要逐个填写的。</p>

<h5>17</h5>

<p><img src="/images/2014/03/09/17.png" alt="temp" />
<strong>contract info</strong>  <br/>
这里第一次进去会需要创建一个新人。然后高管，财务，技术，科技等等职位，都是我一个人担任。</p>

<h5>18</h5>

<p><img src="/images/2014/03/09/18.png" alt="temp" />
<strong>Bank info</strong></p>

<h5>19</h5>

<p><img src="/images/2014/03/09/19.png" alt="temp" />
<strong>CNAPS</strong>，应该是叫“联行号”不要跟银行的人说英文，他们不懂。办信用卡的时候问好，95588这种电话问不到。 <br/>
补充：这里填写的银行号为储蓄卡，千万不能填信用卡的，不然收款都到信用卡里了。 <br/>
查询CNAPS：<a href="https://e.czbank.com/CORPORBANK/query_unionBank_index.jsp">https://e.czbank.com/CORPORBANK/query_unionBank_index.jsp</a></p>

<h5>20</h5>

<p><img src="/images/2014/03/09/20.png" alt="temp" />
这里的信息要写的简洁，要不查不到。</p>

<h5>21</h5>

<p><img src="/images/2014/03/09/21.png" alt="temp" />
添加一个账户信息。</p>

<h5>22</h5>

<p><img src="/images/2014/03/09/22.png" alt="temp" /></p>

<h5>23</h5>

<p><img src="/images/2014/03/09/23.png" alt="temp" />
储蓄卡卡号，名字当然是储蓄卡开户名，比如<strong>Wu Wang</strong>。  <br/>
另外这里收款要选择<strong>USD</strong>，如果选择<strong>RMB</strong>的话，apple打款时是以美元结算的，会多一次汇率转换，白白浪费钱。</p>

<h5>24</h5>

<p><img src="/images/2014/03/09/24.png" alt="temp" /></p>

<h5>25</h5>

<p><img src="/images/2014/03/09/25.png" alt="temp" />
<strong>Tax info</strong>  <br/>
会有几个问题，照实回答，难度不大。  <br/>
给自己随便封个号，我的是chairman。</p>

<h5>26</h5>

<p><img src="/images/2014/03/09/26.png" alt="temp" />
完事会审核，这个很快，吃顿饭就好了。</p>

<h5>27</h5>

<p><img src="/images/2014/03/09/27.png" alt="temp" />
这个事我现在的状态。iAd Network的合同是不小心申请的，其实不用。
时间有点长了，有些细节我慢慢想，慢慢往上写。写的潦草，大家见谅。</p>

<h2>原始链接</h2>

<p><a href="http://watchxxx.blog.163.com/blog/static/1974232272011115112728500/">http://watchxxx.blog.163.com/blog/static/1974232272011115112728500/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Objective-C遍历数组]]></title>
    <link href="http://tmyam.github.io/blog/2014/02/28/objective-cbian-li-shu-zu/"/>
    <updated>2014-02-28T11:46:00+08:00</updated>
    <id>http://tmyam.github.io/blog/2014/02/28/objective-cbian-li-shu-zu</id>
    <content type="html"><![CDATA[<p>数组的遍历有多种方式，这里介绍一下常见的方式，使用以及注意事项。</p>

<h2>常用写法简介</h2>

<h3>1. 经典写法</h3>

<p>``` objective-c
&ndash; (void) test:(NSArray*)array
{</p>

<pre><code>NSInteger count = array.count;
for (NSInteger i = 0 ; i &lt; count ; i ++ )
{
    NSLog(@"%@",array[i]);
}
NSLog(@"end");
</code></pre>

<p>}
```
之所以使用count来存储数组总数，而不是写成 <strong>i &lt; array.count</strong> ,是因为循环每进行一次都会调用数组的计数方法，这将导致性能变得很差。</p>

<!-- more -->


<h3>2. NSEnumerator</h3>

<p>``` objective-c
&ndash; (void) test:(NSArray*)array
{</p>

<pre><code>id test = nil;
NSEnumerator* enumerator = [array objectEnumerator];
while (test = [enumerator nextObject])
{
    NSLog(@"%@",test);
}
NSLog(@"end");
</code></pre>

<p>}
```
NSEnumerator的优势在于不需要知道数据总数，所以它适合应用在结构化数据上，比如链表，数据流等。</p>

<h3>3. 快速枚举</h3>

<p>``` objective-c
&ndash; (void) test:(NSArray*)array
{</p>

<pre><code>for (NSString* test in array )
{
    NSLog(@"%@",test);
}
NSLog(@"end");
</code></pre>

<p>}
```
快速枚举是apple推荐的方式，在使用上比经典的写法性能上更快。 <br/>
使用上如果需要反向枚举，只需要将<strong>array</strong>改成<strong>array.reverseObjectEnumerator</strong>就可以了。</p>

<h3>4. 枚举块</h3>

<p>``` objective-c
&ndash; (void) test:(NSArray*)array
{</p>

<pre><code>[array enumerateObjectsUsingBlock:^(NSString* obj, NSUInteger idx, BOOL *stop) {

     NSLog(@"%@",obj);
}];
NSLog(@"end");
</code></pre>

<p>}
```
枚举块的优势在于它会返回对象和索引, 而其他的枚举方法只会返回对象.</p>

<h2>并发执行</h2>

<p>现在是多核的时代，为了发挥多核的优势，在有些时候并发执行就非常具有优势。如果在枚举中有许多事要做，但并不关心枚举顺序的情况下，使用并发就很合适。 <br/>
但是对于数组总量小一些的数组，并发执行不一定会带来性能提升，反而开销可能远多于其带来的好处。<br/>
所以具体的使用需要自己进行权衡。</p>

<h3>1. 基本的并发枚举块</h3>

<p>``` objective-c
&ndash; (void) test:(NSArray*)array
{</p>

<pre><code>[array enumerateObjectsWithOptions:NSEnumerationConcurrent usingBlock:^(NSString* obj, NSUInteger idx, BOOL *stop) {

    NSLog(@"%@",obj);

}];
NSLog(@"end");
</code></pre>

<p>}
```
这种方式会为每一个枚举创建一个线程，等到所有的枚举都执行完毕才会进行下一步。</p>

<h3>2. 异步GCD并发</h3>

<p>``` objective-c
&ndash; (void) test:(NSArray*)array
{</p>

<pre><code>dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
for(NSString* test in array)
{
    dispatch_async(queue, ^{

        NSLog(@"%@",test);
    });
}
NSLog(@"end");
</code></pre>

<p>}
```
这种方式会为每一个枚举创建一个线程，但是不会等待所有枚举执行完成，而是for循环完成后就会进行下一步了，是一种异步执行的方式。</p>

<h3>3. 等待GCD并发</h3>

<p>``` objective-c
&ndash; (void) test:(NSArray*)array
{</p>

<pre><code>dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
dispatch_group_t group = dispatch_group_create();
for(NSString* test in array)
{
    dispatch_group_async(group, queue, ^{

        NSLog(@"%@",test);
    });
}
dispatch_group_wait(group, DISPATCH_TIME_FOREVER);
dispatch_release(group);
NSLog(@"end");
</code></pre>

<p>}
<code>``
这种方式使用group将多个block组成一组以监测这些Block全部完成或者等待全部完成。这种方式的效果类似于</code>1.基本的并发枚举块`。</p>

<h3>4. dispatch_apply</h3>

<p>``` objective-c
&ndash; (void) test:(NSArray*)array
{</p>

<pre><code>dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
dispatch_apply(array.count, queue, ^(size_t index){

    NSLog(@"%@",array[index]);

});
NSLog(@"end");
</code></pre>

<p>}
<code>``
这是系统提供的一种并发执行方式，这种方式的效果同样类似于</code>1.基本的并发枚举块`。</p>

<br/>


<h3>参考</h3>

<p>本文只是粗略的介绍，如果想了解更详细的使用，建议阅读下面的链接。
<a href="http://www.oschina.net/translate/high-performance-collection-looping-objective-c">http://www.oschina.net/translate/high-performance-collection-looping-objective-c</a></p>

<p><a href="http://www.dreamingwish.com/dream-2012/gcd%E4%BB%8B%E7%BB%8D%EF%BC%88%E4%BA%8C%EF%BC%89-%E5%A4%9A%E6%A0%B8%E5%BF%83%E7%9A%84%E6%80%A7%E8%83%BD.html">http://www.dreamingwish.com/dream-2012/gcd%E4%BB%8B%E7%BB%8D%EF%BC%88%E4%BA%8C%EF%BC%89-%E5%A4%9A%E6%A0%B8%E5%BF%83%E7%9A%84%E6%80%A7%E8%83%BD.html</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Objective-C枚举介绍]]></title>
    <link href="http://tmyam.github.io/blog/2014/02/24/mei-ju-jie-shao/"/>
    <updated>2014-02-24T15:39:00+08:00</updated>
    <id>http://tmyam.github.io/blog/2014/02/24/mei-ju-jie-shao</id>
    <content type="html"><![CDATA[<p>Objective-C枚举的使用，常见的方式总结，以便自己使用时方便查阅。</p>

<h2>1. 枚举介绍</h2>

<h3>enum only</h3>

<p>``` objective-c
enum
{</p>

<pre><code>TMEnumTestOne,
TMEnumTestTwo,
</code></pre>

<p>};</p>

<p>```
* 这种枚举<strong>不推荐</strong>使用，因为不能用一种类型的方式表示枚举。</p>

<!-- more -->


<h3>enum 类型</h3>

<p>``` objective-c
typedef enum
{</p>

<pre><code>TMEnumTestOne,
TMEnumTestTwo,
</code></pre>

<p>} TMEnumTest;</p>

<p><code>
</code> objective-c
enum TMEnumTest
{</p>

<pre><code>TMEnumTestOne,
TMEnumTestTwo,
</code></pre>

<p>};
typedef enum TMEnumTest TMEnumTest;</p>

<p>```
* 这两种写法，将枚举描述为一个类型<em>TMEnumTest</em>。 <br/>
但是这种写法也有局限性，在作为函数参数时，如果传入NSInteger类型的数据，则需要强制转换，否则会有类型不匹配的警告，所以这种方式也<strong>不推荐</strong>。如下图，
<img src="/images/2014/02/24/enum_warn.png" alt="temp" /></p>

<h3>老式enum写法</h3>

<p>``` objective-c
enum
{</p>

<pre><code>TMEnumTestOne,
TMEnumTestTwo,
</code></pre>

<p>};
typedef NSUInteger TMEnumTest;
```
* 这种写法可以指定<em>TMEnumTest</em>的类型，并且作为函数参数时，传入的值不需要进行强制类型转换。 <br/>
但是这种写法不会检查枚举的正确性，是好是坏需要自己判断，如下图。本人<strong>推荐</strong>这种写法。
<img src="/images/2014/02/24/enum_no_check.png" alt="temp" /></p>

<h3>新式enum写法</h3>

<p>``` objective-c
typedef NS_ENUM(NSUInteger, TMEnumTest)
{</p>

<pre><code>TMEnumTestOne,
TMEnumTestTwo,
</code></pre>

<p>};
<code>
</code> objective-c
typedef NS_OPTIONS(NSUInteger, TMEnumTest)
{</p>

<pre><code>TMEnumTestOne  = 0,
TMEnumTestTwo  = 1 &lt;&lt; 0,
</code></pre>

<p>};
```
* <strong>NS_ENUM</strong>和<strong>NS_OPTIONS</strong>本质是一样的，仅仅从字面上来区分用途。<strong>NS_ENUM</strong>是通用情况，<strong>NS_OPTIONS</strong>一般用来定义位枚举。
<a href="http://blog.csdn.net/annkie/article/details/9877643">参考链接</a> <br/>
* 这种写法同样作为函数参数时，传入的值不需要进行强制类型转换。但是也同样不会检查枚举的正确性，和 <strong>老式enum写法</strong> 一样，如下图。
<img src="/images/2014/02/24/enum_no_check.png" alt="temp" />
* 但是不同的是，<strong>新式enum写法</strong> 在使用<em>switch</em>时，会进行值的检测，如果枚举中无此值，则会弹出警告，如下图。这种方式见仁见智了。本人<strong>推荐</strong>这种写法。
<img src="/images/2014/02/24/enum_switch.png" alt="temp" /></p>

<h2>2. 枚举最大值</h2>

<p>对于一般的枚举，要获取枚举的最大值是很难的，因为随着枚举的扩充，最大值在不断变化，这时推荐使用一个固定的枚举表示最大值，例如：
``` objective-c
typedef NS_ENUM(NSUInteger, TMEnumTest)
{</p>

<pre><code>TMEnumTestOne,
TMEnumTestTwo,

TMEnumTestMax,  // 表示最大值
</code></pre>

<p>};
```
这样就可以使用<em>TMEnumTestMax</em>表示枚举<em>TMEnumTest</em>的最大值了。</p>

<h2>3. 位枚举</h2>

<p>位枚举是一种特殊的枚举，在apple的类中使用的很多，例如<code>NSStringCompareOptions</code>等。
``` objective-c
typedef NS_OPTIONS(NSUInteger, TMEnumTest)
{</p>

<pre><code>TMEnumTestOne     = 0,         // 0
TMEnumTestTwo     = 1 &lt;&lt; 0,     // 1
TMEnumTestThree   = 1 &lt;&lt; 1,     // 2
TMEnumTestFour    = 1 &lt;&lt; 2,     // 4
</code></pre>

<p>};
```</p>

<ul>
<li>位枚举的特点是可以使用位运算来处理枚举值，实际使用中可以用一个变量存储多个枚举值，表示互不影响的多个设置。
``` objective-c</li>
<li><p>(void) test
{
  TMEnumTest test = TMEnumTestTwo|TMEnumTestThree;  // 3</p>

<p>  /* 添加TMEnumTestFour到test中（如test已经包含TMEnumTestFour，则test值不变）</p>

<pre><code> 当然这里也可以使用test += TMEnumTestFour,
 但是注意 + 不能在test中已经包含TMEnumTestFour的情况下使用。
</code></pre>

<p>  */
  test |= TMEnumTestFour;  // 7</p>

<p>  /* 将TMEnumTestThree从test中去除（如test不包含TMEnumTestThree，则test值不变）</p>

<pre><code> 当然这里也可以使用test -= TMEnumTestThree，
 但是注意 - 不能在test中不包含TMEnumTestThree的情况下使用。
</code></pre>

<p>  */  <br/>
  test &amp;= ~TMEnumTestThree; // 5</p>

<p>  // 判断 TMEnumTestFour枚举 是否被包含
  if ((test &amp; TMEnumTestFour) == TMEnumTestFour)
  {
      NSLog(@&ldquo;YES&rdquo;);
  }</p>

<p>  /* 判断 TMEnumTestFour枚举 是否被包含</p>

<p>   因为 (test &amp; TMEnumTestFour) 的结果不是 0，就是TMEnumTestFour本身，
   而 TMEnumTestFour > 0 ，所以可以使用简易的判断
   */
  if (test &amp; TMEnumTestFour)
  {
      NSLog(@&ldquo;YES&rdquo;);
  }
}
```</p></li>
</ul>

]]></content>
  </entry>
  
</feed>
